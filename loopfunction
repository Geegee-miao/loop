## Loop Functions

## Looping on the Command Line
# Writing for , while loops is useful when programming but not particularyly easy when working 
# interactively on the command line. There are some functions which implement looping to make life
# easier.

# 'lapply' : Loop over a list and evaluate a function on each element
# 'sapply' : Same as 'lapply' but try to simplify the result
# 'apply' : Apply a function over the margins of an array
# 'tapply' : Apply a function over subsets of a vector
# 'mapply' : Multivariate version of 'lapply'

# An auxiliary function 'split' is also useful, particularly in conjuction with 'lapply'. Splits objects
# into sub pieces.

## 'lapply'

# 'lapply' takes three arguments: (1) a list x; (2) a function (or the name of a function) FUN;
# (3) other argumetns via its ... argument. If x is not a list, it will be coerced to a list using
# 'as.list'.

## function (X,FUN, ...)
## {
##      FUN <- match.fun(FUN)
##      if(!is.vector(X) || is.object(X))
##          x <- as.list(X)
##      .Internal(lapply(X, FUN))
## }
## <bytecode: 0x7ff7a1951c00>
## <environment: namespace:base>

### The actual looping is done internally in C code

## 'lapply' always returns a list, regardless of the class of the input.

x <- list(a = 1:5, b = rnorm(10))  # a list can be a vector, number, character or data frames. (eg. create a list of two elements. first one is a sequence from 1 to 5 and the second is a 10 or more random variables.)
lapply(x,mean) # always return as a list


x <- list(a = 1:4, b = rnorm(10), c = rnorm(20,1), d = rnorm(100, 5))
lapply(x,mean)  # 'x' is the list; 'mean' is the function


x <- 1:4
lapply(x, runif)  # 'runif' generate uniform random variables


x <- 1:4
lapply(x, runif, min = 0, max = 10)  # specify the min/max for the random uniform between 0 & 10


## 'lapply' and friends make heavy use of anonymous functions

x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 

lapply(x, function(elt) elt[,1])  # An anonymous function for extracting the first column of each matrix.



### 'sapply'
## 'sapply' a variant of 'lapply'. 'sapply' will try to simplify the result of 'lapply' if possible.
# - If the result is a list where every element is length 1, then a vector is returned.
# - If the result is a list where every element is a vector of the same length (>1), a matrix is returned.
# If it can't figure things out, a list is returned.

x <- list(a = 1:4, b = rnorm(10), c = rnorm(20,1), d = rnorm(100,5))
lapply(x, mean)  # return a list of every element of the list is a single number

sapply(x,mean)  # return a vector with numbers in it

mean(x)  # not going to work because 'mean' is not meant to be applied to lists
x



## 'apply' Function

# 'apply' is used to evaluate a function (often an anonymous one) over the margins of an array.
# It is most often used to apply a function to the rows or columns of a matrix.
# It can be used with general arrays, e.g. taking the average of an array of matrices.
# It is not really faster than writing a loop, but it works in one line! Less typing.

str(apply)
function (X, MARGIN, FUN, ...)   

## "X" is an array
## "MARGIN" is an integer vector indicating which margins be "retained".
## "FUN" is a function to be applied
## "..." is for other arguments to be passed to 'FUN'
    
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean) # calculate the mean of each column of the matrix. 
                  # When 'apply' the function, mean, over the matrix, the idea is to keep the second dimension, which 
                  # is the number of columns and collapse the first dimension, which is the rows. Idea is to take the mean across all the rows in each column.



apply(x, 1, sum)  # calculate the sum of each rows. Preserve the rows and collapse the columns.
                  # Results show vector of 20 because there's 20 rows. 


    
## 'col/row' sums and means
# For sums and means of matrix dimensions, we have some shortcuts.
# 'rowSums = apply(x, 1, sum)'
# 'rowMeans = apply(x, 1, mean)'
# 'colSums = apply(x, 2, sum)'
# 'colMeans = apply(x, 2, means)'

    ## The shortcut functions are much faster, but you won't notice unless you're using a large matrix.


## Other Ways to Apply
# Quantiles of the rows of a matrix.

x <- matric(rnorm(200), 20, 10)
apply(x, 1, quantile, probs = c(0.25, 0.75))  ## calculate the 25th and 75th percentile of that row.



## Average matrix in an array

a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1,2), mean)

rowMeans(a, dims = 2)


## 'mapply' is a multivariate apply of sorts which applies a function in parallel over a set of arguments.

str(mapply)
function(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE,
         USE.NAMES = TRUE)
# 'FUN' is a function to apply
# '...' contains arguments to apply over
# 'MoreArgs' is a list of other arguments to 'FUN'
# 'SIMPLIFY' indicates whether the result should be simplified

# The following is tedious to type
    # list(rep(1, 4), rep(2, 3), rep(3,2), rep(4, 1))

# Instead we can do
mapply(rep, 1:4, 4:1)  # 'rep' function, arg 1, arg 2

[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4



## Vectorising a Function
noise <- function(n, mean, sd) {
    rnorm(n, mean, sd)
}

noise(5, 1, 2)
[1]  3.0678478  1.1297184  4.3804458 -0.2680928 -0.9224650

noise(1:5, 1:5, 2)
[1]  2.63445150 -0.06358438  3.72460905 -1.80284691  4.74088777

## Instant Vectorisation
mapply(noise, 1:5, 1:5, 2)

[[1]]
[1] 3.880207

[[2]]
[1] 5.157993 1.847104

[[3]]
[1] 2.8981492 0.9101343 3.3081148

[[4]]
[1] 4.143689 4.223154 2.437585 2.300432

[[5]]
[1] 5.328248 6.541058 3.589893 9.111251 6.379555


## Same as Instant Vectorisation
list(noise(1, 1, 2), noise(2, 2, 2), noise(3, 3, 2), noise(4, 4, 2), noise (5, 5, 2))

[[1]]
[1] -1.598752

[[2]]
[1] 2.280979 3.965332

[[3]]
[1] 5.827060 3.369491 4.488848

[[4]]
[1] 4.106870 2.066759 4.799796 3.288072

[[5]]
[1] 3.034927 3.912387 8.175709 4.694332 5.882148



## 'tapply' is used to apply a function over subsets of a vector. 

str(tapply)
    function( X, INDEX, FUN = NULL, ..., simplify = TRUE )
# 'X' is a vector
# 'INDEX' is a factor or a list of factors (or else they are coerced to factors)
# 'FUN' is a function to be applied
# '...' contains other arguments to be passed FUN
# 'simplify', should we simplify the result?
        
# Take group means.
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
f
[1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3
Levels: 1 2 3

tapply(x, f, mean)
1         2         3 
0.1168819 0.4202747 1.8407198 

# Take group means without simplification. The results will be a list with mean of subgroup
tapply(x, f, mean, simplify = FALSE)
$`1`
[1] 0.1168819

$`2`
[1] 0.4202747

$`3`
[1] 1.84072


## Instead of calculating the mean which returns one number. Here calculate the range of observations.
# The min and max of the observations within that subset of the vector x.
# The result is a list where each element is a vector of length 2.
tapply(x, f, range)
$`1`
[1] -2.525966  2.333217

$`2`
[1] 0.1108824 0.8440086

$`3`
[1] 0.3246664 3.1761659


## 'tapply' is useful because it splits up a vector. 'split' takes a vector or other objects and
# splits it into groups determined by a factor or list of factors.

str(split)
    function(x, f, drop = FALSE, ...)
# "x" is a vector (or list) or data frame. 
# "f" is a factor ( or coerced to one) or a list of factors. So if "f" has 3 levels identifying 3 groups
    # then the 'split' function will split "x", into 3 groups.
# Once those groups split apart, you can use 'lapply' or 'sapply' to apply a function to those individual groups.
# 'drop' indicates whether empty factors levels should be dropped
       
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
split(x, f)

$`1`
[1] -0.5453065 -0.2016810 -0.5173864  0.6321936 -1.0429043  0.5807360
[7]  0.8836957  0.5668343 -1.7024216 -1.3451777

$`2`
[1] 0.683601605 0.219873971 0.994922749 0.418686160 0.233687892 0.761974770
[7] 0.008312135 0.263116128 0.825682656 0.708309882

$`3`
[1] -0.2672253 -0.4216143  0.1639556  0.8281599  1.4563658  2.6838594
[7]  0.4989963 -0.6328541  3.0205253  0.7457476


# A common idiom is 'split' followed by an 'lapply'
lapply(split(x, f), mean)

$`1`
[1] -0.2691418

$`2`
[1] 0.5118168

$`3`
[1] 0.8075916


# Splitting a Data Frame
library(datasets)
head(airquality)

Ozone Solar.R Wind Temp Month Day
1    41     190  7.4   67     5   1
2    36     118  8.0   72     5   2
3    12     149 12.6   74     5   3
4    18     313 11.5   62     5   4
5    NA      NA 14.3   56     5   5
6    28      NA 14.9   66     5   6

## Calculate the mean of ozone, solar radiation, wind and temperature within each month.
## split the data frame into monthly pieces (separate month), then calculate the means, the columns means
    # using either apply or call means on those other variables.

s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar R.", "Wind")]))

## If there is NA as missing value, the mean result will return NA.


## USING 'sapply' will simplify the result because each element of the returned list has a vector
# of length 3 and put all these numbers into a matrix instead of a list.  3 rows and 5 columns

sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))

5         6          7        8        9
Ozone         NA        NA         NA       NA       NA
Solar.R       NA 190.16667 216.483871       NA 167.4333
Wind    11.62258  10.26667   8.941935 8.793548  10.1800

## Remove NA values before calculating the mean.
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE))

5         6          7          8         9
Ozone    23.61538  29.44444  59.115385  59.961538  31.44828
Solar.R 181.29630 190.16667 216.483871 171.857143 167.43333
Wind     11.62258  10.26667   8.941935   8.793548  10.18000



## Splitting in more than one level

x <- rnorm(10)
f1 <- gl(2,5)
f2 <- gl(5,2)

f1
[1] 1 1 1 1 1 2 2 2 2 2
Levels: 1 2

f2
[1] 1 1 2 2 3 3 4 4 5 5
Levels: 1 2 3 4 5

## Combine all the level of f1 and f2
interaction(f1, f2)
[1] 1.1 1.1 1.2 1.2 1.3 2.3 2.4 2.4 2.5 2.5
Levels: 1.1 2.1 1.2 2.2 1.3 2.3 1.4 2.4 1.5 2.5

str(split(x, list(f1, f2)))
List of 10
$ 1.1: num [1:2] -0.311 -2.738
$ 2.1: num(0) 
$ 1.2: num [1:2] -1.09 -1.48
$ 2.2: num(0) 
$ 1.3: num 1.01
$ 2.3: num -0.78
$ 1.4: num(0) 
$ 2.4: num [1:2] 0.475 -0.636
$ 1.5: num(0) 
$ 2.5: num [1:2] 1.42 1.79


## Use 'drop = TRUE' to drop empty levels and return a list with only observation levels
str(split(x, list(f1, f2), drop = TRUE))
List of 6
$ 1.1: num [1:2] -0.311 -2.738
$ 1.2: num [1:2] -1.09 -1.48
$ 1.3: num 1.01
$ 2.3: num -0.78
$ 2.4: num [1:2] 0.475 -0.636
$ 2.5: num [1:2] 1.42 1.79



## DEBUGGING TOOLS
    # Not part of any package. 

# Indications that something's not right
# 'message': A generic notification/diagnostic message produced by the 'message' function; 
    # execution of the function continues
# 'warning': An indication that something is wrong but not necessarily fatal; execution of the 
    # function continues; generated by the 'warning' function
# 'error': An indication that a fatal problem has occurred; execution stops; produced by the 'stop'
    # function
# 'condition': A generic concept for indicating that something unexpected can occur; programmers
    # can create their own conditions

## Example of a warning
log(-1)
[1] NaN
Warning message:
    In log(-1) : NaNs produced


## 'invisible' is a function that prevents auto printing. Can call the function and the 
    # object will return but it won't do the auto printing to the console
printmessage <- function(x) {
    if(x > 0)
        print("x is greater than zero")
    else
        print("x is less than or equal to zero")
    invisible(x)
}


## 'printmessage' returns its argument
printmessage(1)
[1] "x is greater than zero"


## NA is not a value that return TRUE/FALSE
printmessage(NA)
Error in if (x > 0) print("x is greater than zero") else print("x is less than or equal to zero") : 
    missing value where TRUE/FALSE needed


## To include a NA return
printmessage2 <- function(x) {
    if(is.na(x))
        print("x is a missing value")
    else if (x > 0)
        print("x is greater than zero")
    else 
        print("x is less than or equal to zero")
    invisible(x)
}

printmessage2(NA)
[1] "x is a missing value"

x <- log(-1)
Warning message:
    In log(-1) : NaNs produced

printmessage2(x)
[1] "x is a missing value"

## How do you know that something is wrong with your function?
    # What was your input? How did you call the function?
    # What were you expecting? Output, messages, other results?
    # What did you get?
    # How does what you get differ from what you were expecting?
    # Were you expectations correct in the first place?
    # Can you reproduce the problem (exactly)?

## DEBUGGING TOOLS IN R

# The primary tools for debugging functions in R are
    # 'traceback': prints out the function call stak=ck after an error occurs; does nothing
        # if there's no error.
    # 'debug': flags a function for "debug" mode which allows you to step through executions of
        # a function one line at a time.
    # 'browser': suspends the execution of a function wherever it is called and puts the 
        # function in debug mode
    # 'trace': allows you to insert debugging code into a function a specific places
    # 'recover': allows you to modify the error behaviour so that you can browse the function call
        # stack

# These are interactive tools specifically designed to allow you to pick through a function. There's
    # also the more blunt technique of inserting print/cat statements in the function.


## Example of 'traceback'. Must be call immediately after the error occurs
mean(x)
[1] NaN
traceback()
1: printmessage(NA)


> lm(y - x)
Error in eval(mf, parent.frame()) : object 'y' not found
traceback()
4: stats::model.frame(formula = y - x, drop.unused.levels = TRUE)
3: eval(mf, parent.frame())
2: eval(mf, parent.frame())
1: lm(y - x)


## 'debug' function
debug(lm)
lm(y - x)
## the whole function code
debugging in: lm(y - x)
debug: {
    ret.x <- x
    ret.y <- y
    cl <- match.call()
    mf <- match.call(ex
z$x <- x
if (ret.y) 
    z$y <- y
if (!qr) 
    z$qr <- NULL
z
}
Browse[1]> n ## The browser if your R workspace (work space embedded within a work space)
             ## "n" is next. so run the next code by "n" enter until the error code


## 'recover' function
option(error = recover)
read.csv("nosuchfile")
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
    In file(file, "rt") :
    cannot open file 'nosuchfile': No such file or directory



## SUMMARY DEBUGGING

# There are 3 main indications of a problem/condition: message, warning, error
    # only an 'error' is fatal and stops the function execution

# When analysing a function with a problem, make sure you can reproduce the problem, clearly
    # state your expectations and how the output differs from your expectations

# Interactive debugging tools 'traceback, debug, browser, trace' and 'recover' can be used to 
    # find problematic code in functions

# Debugging tools are not a substitute for thinking!

library("swirl")
swirl()



## Swirl Exercises in Loop Functions

head(flags)

name landmass zone area population language religion bars
1    Afghanistan        5    1  648         16       10        2    0
2        Albania        3    1   29          3        6        6    0
3        Algeria        4    1 2388         20        8        2    2
4 American-Samoa        6    3    0          0        1        1    0
5        Andorra        3    1    0          0        6        0    3
6         Angola        4    2 1247          7       10        5    0
stripes colours red green blue gold white black orange mainhue circles
1       3       5   1     1    0    1     1     1      0   green       0
2       0       3   1     0    0    1     0     1      0     red       0
3       0       3   1     1    0    0     1     0      0   green       0
4       0       5   1     0    1    1     1     0      1    blue       0
5       0       3   1     0    1    1     0     0      0    gold       0
6       2       3   1     0    0    1     0     1      0     red       0
crosses saltires quarters sunstars crescent triangle icon animate text
1       0        0        0        1        0        0    1       0    0
2       0        0        0        1        0        0    0       1    0
3       0        0        0        1        1        0    0       0    0
4       0        0        0        0        0        1    1       1    0
5       0        0        0        0        0        0    0       0    0
6       0        0        0        1        0        0    1       0    0
topleft botright
1   black    green
2     red      red
3   green    white
4    blue      red
5    blue      red
6     red    black

Now, let's check out
| the dimensions of the dataset using dim(flags).

> dim(flags)
[1] 194  30   ## 194 rows or observations and 30 columns or variables.
             ## Each observation is a country and each variable describes some characteristic of
                # that country or its flag.


As with any dataset, we'd like to know in what format the variables have
| been stored. In other words, what is the 'class' of each variable? What
| happens if we do class(flags)? Try it out.

> class(flags)
[1] "data.frame"

| The lapply() function takes a list as input, applies a function to each
| element of the list, then returns a list of the same length as the
| original one. Since a data frame is really just a list of vectors (you can
                                                                     | see this with as.list(flags)), we can use lapply() to apply the class()
| function to each column of the flags dataset. Let's see it in action!

...

  |===============                                                    |  22%
| Type cls_list <- lapply(flags, class) to apply the class() function to
| each column of the flags dataset and store the result in a variable called
| cls_list. Note that you just supply the name of the function you want to
| apply (i.e. class), without the usual parentheses after it.

> cls_list <- lapply(flags, class)

> cls_list
$name
[1] "character"

$landmass
[1] "integer"

$zone
[1] "integer"

$area
[1] "integer"

$population
[1] "integer"

$language
[1] "integer"

$religion
[1] "integer"


The 'l' in 'lapply' stands for 'list'. Type class(cls_list) to confirm
| that lapply() returned a list.

> class(cls_list)
[1] "list"

| As expected, we got a list of length 30 -- one element for each
| variable/column. The output would be considerably more compact if we could
| represent it as a vector instead of a list.

...

  |====================                                               |  30%
| You may remember from a previous lesson that lists are most helpful for
| storing multiple classes of data. In this case, since every element of the
| list returned by lapply() is a character vector of length one (i.e.
| "integer" and "vector"), cls_list can be simplified to a character vector.
| To do this manually, type as.character(cls_list).

> as.character(cls_list)
 [1] "character" "integer"   "integer"   "integer"   "integer"   "integer"  
 [7] "integer"   "integer"   "integer"   "integer"   "integer"   "integer"  
[13] "integer"   "integer"   "integer"   "integer"   "integer"   "character"
[19] "integer"   "integer"   "integer"   "integer"   "integer"   "integer"  
[25] "integer"   "integer"   "integer"   "integer"   "character" "character"



 sapply() allows you to automate this process by calling lapply() behind
| the scenes, but then attempting to simplify (hence the 's' in 'sapply')
| the result for you. Use sapply() the same way you used lapply() to get the
| class of each column of the flags dataset and store the result in
| cls_vect. If you need help, type ?sapply to bring up the documentation.

> cls_vect <- sapply(flags, class)

| Use class(cls_vect) to confirm that sapply() simplified the result to a
| character vector.

> class(cls_vect)
[1] "character"

 In general, if the result is a list where every element is of length one,
| then sapply() returns a vector. If the result is a list where every
| element is a vector of the same length (> 1), sapply() returns a matrix.
| If sapply() can't figure things out, then it just returns a list, no
| different from what lapply() would give you.

| Columns 11 through 17 of our dataset are indicator variables, each
| representing a different color. The value of the indicator variable is 1
| if the color is present in a country's flag and 0 otherwise.

...

  |============================                                       |  42%
| Therefore, if we want to know the total number of countries (in our
| dataset) with, for example, the color orange on their flag, we can just
| add up all of the 1s and 0s in the 'orange' column. Try sum(flags$orange)
| to see this.

> sum(flags$orange)
[1] 26

| First, use flag_colors <- flags[, 11:17] to extract the columns containing
| the color data and store them in a new data frame called flag_colors.
| (Note the comma before 11:17. This subsetting command tells R that we want
| all rows, but only columns 11 through 17.)

> flag_colors <- flags[, 11:17]

| Use the head() function to look at the first 6 lines of flag_colors.

> head(flag_colors)
  red green blue gold white black orange
1   1     1    0    1     1     1      0
2   1     0    0    1     0     1      0
3   1     1    0    0     1     0      0
4   1     0    1    1     1     0      1
5   1     0    1    1     0     0      0
6   1     0    0    1     0     1      0


| To get a list containing the sum of each column of flag_colors, call the
| lapply() function with two arguments. The first argument is the object
| over which we are looping (i.e. flag_colors) and the second argument is
| the name of the function we wish to apply to each column (i.e. sum).
| Remember that the second argument is just the name of the function with no
| parentheses, etc.

> lapply(flag_colors, sum)
$red
[1] 153

$green
[1] 91

$blue
[1] 99

$gold
[1] 91

| This tells us that of the 194 flags in our dataset, 153 contain the color
| red, 91 contain green, 99 contain blue, and so on.


> sapply(flag_colors, sum)
   red  green   blue   gold  white  black orange 
   153     91     99     91    146     52     26 
   

 Use sapply() to apply the mean() function to each column of flag_colors.
| Remember that the second argument to sapply() should just specify the name
| of the function (i.e. mean) that you want to apply.

> sapply(flag_colors, mean)
      red     green      blue      gold     white     black    orange 
0.7886598 0.4690722 0.5103093 0.4690722 0.7525773 0.2680412 0.1340206 


| The range() function returns the minimum and maximum of its first
| argument, which should be a numeric vector. Use lapply() to apply the
| range function to each column of flag_shapes. Don't worry about storing
| the result in a new variable. By now, we know that lapply() always returns
| a list.

> lapply(flag_shapes, range)
$circles
[1] 0 4

$crosses
[1] 0 2

$saltires
[1] 0 1

$quarters
[1] 0 4


Do the same operation, but using sapply() and store the result in a
| variable called shape_mat.

> shape_mat <- sapply(flag_shapes, range)

| Great job!
    
    |===============================================                    |  70%
| View the contents of shape_mat.

> shape_mat
circles crosses saltires quarters sunstars
[1,]       0       0        0        0        0
[2,]       4       2        1        4       50


| When given a vector, the unique() function returns a vector with all
| duplicate elements removed. In other words, unique() returns a vector of
| only the 'unique' elements. To see how it works, try unique(c(3, 4, 5, 5,
                                                                | 5, 6, 6)).

> unique(c(3, 4, 5, 5, 5, 6))
[1] 3 4 5 6


Since unique_vals is a list, you can use what you've learned to determine
| the length of each element of unique_vals (i.e. the number of unique
| values for each variable). Simplify the result, if possible. Hint: Apply
| the length() function to each element of unique_vals.

> sapply(unique_vals, length)
      name   landmass       zone       area population   language   religion 
       194          6          4        136         48         10          8 
      bars    stripes    colours        red      green       blue       gold 
         5         12          8          2          2          2          2 
     white      black     orange    mainhue    circles    crosses   saltires 
         2          2          2          8          4          3          2 
  quarters   sunstars   crescent   triangle       icon    animate       text 
         3         14          2          2          2          2          2 
   topleft   botright 
         7          8 
         
         

| lapply(unique_vals, function(elem) elem[2]) will return a list containing
| the second item from each element of the unique_vals list. Note that our
| function takes one argument, elem, which is just a 'dummy variable' that
| takes on the value of each element of unique_vals, in turn.

> lapply(unique_vals, function(elem) elem[2])
$name
[1] "Albania"   ## The second country on the list.

$landmass
[1] 3

$zone
[1] 3

$area
[1] 29

$population
[1] 3

$language
[1] 6

$religion
[1] 6

$bars
[1] 2

$stripes
[1] 0

$colours
[1] 3

$red
[1] 0




| In this lesson, you'll learn how to use vapply() and tapply(), each of
| which serves a very specific purpose within the Split-Apply-Combine
| methodology. For consistency, we'll use the same dataset we used in the
| 'lapply and sapply' lesson.

| Whereas sapply() tries to 'guess' the correct format of the result,
| vapply() allows you to specify it explicitly. If the result doesn't match
| the format you specify, vapply() will throw an error, causing the
| operation to stop. This can prevent significant problems in your code that
| might be caused by getting unexpected return values from sapply().

...

|=====================                                              |  32%
| Try vapply(flags, unique, numeric(1)), which says that you expect each
| element of the result to be a numeric vector of length 1. Since this is
| NOT actually the case, YOU WILL GET AN ERROR. Once you get the error, type
| ok() to continue to the next question.

> vapply(flags, unique, numeric(1))
Error in vapply(flags, unique, numeric(1)) : values must be length 1,
but FUN(X[[1]]) result is length 194

| If we wish to be explicit about the format of the result we expect, we can
| use vapply(flags, class, character(1)). The 'character(1)' argument tells
| R that we expect the class function to return a character vector of length
| 1 when applied to EACH column of the flags dataset. Try it now.


## Same return as sapply(flags, class)

> vapply(flags, class, character(1))
name    landmass        zone        area  population    language 
"character"   "integer"   "integer"   "integer"   "integer"   "integer" 
religion        bars     stripes     colours         red       green 
"integer"   "integer"   "integer"   "integer"   "integer"   "integer" 
blue        gold       white       black      orange     mainhue 
"integer"   "integer"   "integer"   "integer"   "integer" "character" 
circles     crosses    saltires    quarters    sunstars    crescent 
"integer"   "integer"   "integer"   "integer"   "integer"   "integer" 
triangle        icon     animate        text     topleft    botright 
"integer"   "integer"   "integer"   "integer" "character" "character" 

Note that since our expectation was correct (i.e. character(1)), the
| vapply() result is identical to the sapply() result -- a character vector
| of column classes.


| As a data analyst, you'll often wish to split your data up into groups
| based on the value of some variable, then apply a function to the members
| of each group. The next function we'll look at, tapply(), does exactly
| that.


| The 'landmass' variable in our dataset takes on integer values between 1
| and 6, each of which represents a different part of the world. Use
| table(flags$landmass) to see how many flags/countries fall into each
| group.

> table(flags$landmass)

1  2  3  4  5  6 
31 17 35 52 39 20 

| Print the value of unique_vals to the console.

> unique_vals
$name
[1] "Afghanistan"              "Albania"                 
[3] "Algeria"                  "American-Samoa"          
[5] "Andorra"                  "Angola"                  
[7] "Anguilla"                 "Antigua-Barbuda"         
[9] "Argentina"                "Argentine"               
[11] "Australia"                "Austria"                 
[13] "Bahamas"                  "Bahrain"                 
[15] "Bangladesh"               "Barbados"                
[17] "Belgium"                  "Belize"                  
[19] "Benin"                    "Bermuda"                 
[21] "Bhutan"                   "Bolivia"                 
[23] "Botswana"                 "Brazil"                  
[25] "British-Virgin-Isles"     "Brunei"                  
[27] "Bulgaria"                 "Burkina"                 
[29] "Burma"                    "Burundi"                 
[31] "Cameroon"                 "Canada"                  
[33] "Cape-Verde-Islands"       "Cayman-Islands"          
[35] "Central-African-Republic" "Chad"                    
[37] "Chile"                    "China"                   
[39] "Colombia"                 "Comorro-Islands"         
[41] "Congo"                    "Cook-Islands"            
[43] "Costa-Rica"               "Cuba"                    
[45] "Cyprus"                   "Czechoslovakia"          
[47] "Denmark"                  "Djibouti"                
[49] "Dominica"                 "Dominican-Republic"      
[51] "Ecuador"                  "Egypt"                   
[53] "El-Salvador"              "Equatorial-Guinea"       
[55] "Ethiopia"                 "Faeroes"                 
[57] "Falklands-Malvinas"       "Fiji"                    
[59] "Finland"                  "France"                  
[61] "French-Guiana"            "French-Polynesia"        
[63] "Gabon"                    "Gambia"                  
[65] "Germany-DDR"              "Germany-FRG"             
[67] "Ghana"                    "Gibraltar"               
[69] "Greece"                   "Greenland"               
[71] "Grenada"                  "Guam"                    
[73] "Guatemala"                "Guinea"                  
[75] "Guinea-Bissau"            "Guyana"                  
[77] "Haiti"                    "Honduras"                
[79] "Hong-Kong"                "Hungary"                 
[81] "Iceland"                  "India"                   
[83] "Indonesia"                "Iran"                    
[85] "Iraq"                     "Ireland"                 
[87] "Israel"                   "Italy"                   
[89] "Ivory-Coast"              "Jamaica"                 
[91] "Japan"                    "Jordan"                  
[93] "Kampuchea"                "Kenya"                   
[95] "Kiribati"                 "Kuwait"                  
[97] "Laos"                     "Lebanon"                 
[99] "Lesotho"                  "Liberia"                 
[101] "Libya"                    "Liechtenstein"           
[103] "Luxembourg"               "Malagasy"                
[105] "Malawi"                   "Malaysia"                
[107] "Maldive-Islands"          "Mali"                    
[109] "Malta"                    "Marianas"                
[111] "Mauritania"               "Mauritius"               
[113] "Mexico"                   "Micronesia"              
[115] "Monaco"                   "Mongolia"                
[117] "Montserrat"               "Morocco"                 
[119] "Mozambique"               "Nauru"                   
[121] "Nepal"                    "Netherlands"             
[123] "Netherlands-Antilles"     "New-Zealand"             
[125] "Nicaragua"                "Niger"                   
[127] "Nigeria"                  "Niue"                    
[129] "North-Korea"              "North-Yemen"             
[131] "Norway"                   "Oman"                    
[133] "Pakistan"                 "Panama"                  
[135] "Papua-New-Guinea"         "Parguay"                 
[137] "Peru"                     "Philippines"             
[139] "Poland"                   "Portugal"                
[141] "Puerto-Rico"              "Qatar"                   
[143] "Romania"                  "Rwanda"                  
[145] "San-Marino"               "Sao-Tome"                
[147] "Saudi-Arabia"             "Senegal"                 
[149] "Seychelles"               "Sierra-Leone"            
[151] "Singapore"                "Soloman-Islands"         
[153] "Somalia"                  "South-Africa"            
[155] "South-Korea"              "South-Yemen"             
[157] "Spain"                    "Sri-Lanka"               
[159] "St-Helena"                "St-Kitts-Nevis"          
[161] "St-Lucia"                 "St-Vincent"              
[163] "Sudan"                    "Surinam"                 
[165] "Swaziland"                "Sweden"                  
[167] "Switzerland"              "Syria"                   
[169] "Taiwan"                   "Tanzania"                
[171] "Thailand"                 "Togo"                    
[173] "Tonga"                    "Trinidad-Tobago"         
[175] "Tunisia"                  "Turkey"                  
[177] "Turks-Cocos-Islands"      "Tuvalu"                  
[179] "UAE"                      "Uganda"                  
[181] "UK"                       "Uruguay"                 
[183] "US-Virgin-Isles"          "USA"                     
[185] "USSR"                     "Vanuatu"                 
[187] "Vatican-City"             "Venezuela"               
[189] "Vietnam"                  "Western-Samoa"           
[191] "Yugoslavia"               "Zaire"                   
[193] "Zambia"                   "Zimbabwe"                

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
[1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31
[13]    23   113    47  1099   600  8512     6   111   274   678    28   474
[25]  9976     4   623  1284   757  9561  1139     2   342    51   115     9
[37]   128    43    22    49   284  1001    21  1222    12    18   337   547
[49]    91   268    10   108   249   239   132  2176   109   246    36   215
[61]   112    93   103  3268  1904  1648   435    70   301   323    11   372
[73]    98   181   583   236    30  1760     3   587   118   333  1240  1031
[85]  1973  1566   447   783   140    41  1267   925   121   195   324   212
[97]   804    76   463   407  1285   300   313    92   237    26  2150   196
[109]    72   637  1221    99   288   505    66  2506    63    17   450   185
[121]   945   514    57     5   164   781   245   178  9363 22402    15   912
[133]   256   905   753   391

$population
[1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9
[15]   35    4   24    2   11 1008    5   47   31   54   17   61   14  684
[29]  157   39   57  118   13   77   12   56   18   84   48   36   22   29
[43]   38   49   45  231  274   60

$language
[1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
[1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] "green"  "red"    "blue"   "gold"   "white"  "orange" "black"  "brown" 

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
[1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] "black"  "red"    "green"  "blue"   "white"  "orange" "gold"  

$botright
[1] "green"  "red"    "white"  "black"  "blue"   "gold"   "orange" "brown" 


| You are amazing!
    
    |========================================================           |  84%
| Since unique_vals is a list, you can use what you've learned to determine
| the length of each element of unique_vals (i.e. the number of unique
| values for each variable). Simplify the result, if possible. Hint: Apply
| the length() function to each element of unique_vals.

> sapply(unique_vals, length)
      name   landmass       zone       area population   language   religion 
       194          6          4        136         48         10          8 
      bars    stripes    colours        red      green       blue       gold 
         5         12          8          2          2          2          2 
     white      black     orange    mainhue    circles    crosses   saltires 
         2          2          2          8          4          3          2 
  quarters   sunstars   crescent   triangle       icon    animate       text 
         3         14          2          2          2          2          2 
   topleft   botright 
         7          8 

| Keep up the great work!

  |==========================================================         |  86%
| The fact that the elements of the unique_vals list are all vectors of
| *different* length poses a problem for sapply(), since there's no obvious
| way of simplifying the result.

...

|===========================================================        |  88%
| Use sapply() to apply the unique() function to each column of the flags
| dataset to see that you get the same unsimplified list that you got from
| lapply().

> sapply(flags, unique)
$name
[1] "Afghanistan"              "Albania"                 
[3] "Algeria"                  "American-Samoa"          
[5] "Andorra"                  "Angola"                  
[7] "Anguilla"                 "Antigua-Barbuda"         
[9] "Argentina"                "Argentine"               
[11] "Australia"                "Austria"                 
[13] "Bahamas"                  "Bahrain"                 
[15] "Bangladesh"               "Barbados"                
[17] "Belgium"                  "Belize"                  
[19] "Benin"                    "Bermuda"                 
[21] "Bhutan"                   "Bolivia"                 
[23] "Botswana"                 "Brazil"                  
[25] "British-Virgin-Isles"     "Brunei"                  
[27] "Bulgaria"                 "Burkina"                 
[29] "Burma"                    "Burundi"                 
[31] "Cameroon"                 "Canada"                  
[33] "Cape-Verde-Islands"       "Cayman-Islands"          
[35] "Central-African-Republic" "Chad"                    
[37] "Chile"                    "China"                   
[39] "Colombia"                 "Comorro-Islands"         
[41] "Congo"                    "Cook-Islands"            
[43] "Costa-Rica"               "Cuba"                    
[45] "Cyprus"                   "Czechoslovakia"          
[47] "Denmark"                  "Djibouti"                
[49] "Dominica"                 "Dominican-Republic"      
[51] "Ecuador"                  "Egypt"                   
[53] "El-Salvador"              "Equatorial-Guinea"       
[55] "Ethiopia"                 "Faeroes"                 
[57] "Falklands-Malvinas"       "Fiji"                    
[59] "Finland"                  "France"                  
[61] "French-Guiana"            "French-Polynesia"        
[63] "Gabon"                    "Gambia"                  
[65] "Germany-DDR"              "Germany-FRG"             
[67] "Ghana"                    "Gibraltar"               
[69] "Greece"                   "Greenland"               
[71] "Grenada"                  "Guam"                    
[73] "Guatemala"                "Guinea"                  
[75] "Guinea-Bissau"            "Guyana"                  
[77] "Haiti"                    "Honduras"                
[79] "Hong-Kong"                "Hungary"                 
[81] "Iceland"                  "India"                   
[83] "Indonesia"                "Iran"                    
[85] "Iraq"                     "Ireland"                 
[87] "Israel"                   "Italy"                   
[89] "Ivory-Coast"              "Jamaica"                 
[91] "Japan"                    "Jordan"                  
[93] "Kampuchea"                "Kenya"                   
[95] "Kiribati"                 "Kuwait"                  
[97] "Laos"                     "Lebanon"                 
[99] "Lesotho"                  "Liberia"                 
[101] "Libya"                    "Liechtenstein"           
[103] "Luxembourg"               "Malagasy"                
[105] "Malawi"                   "Malaysia"                
[107] "Maldive-Islands"          "Mali"                    
[109] "Malta"                    "Marianas"                
[111] "Mauritania"               "Mauritius"               
[113] "Mexico"                   "Micronesia"              
[115] "Monaco"                   "Mongolia"                
[117] "Montserrat"               "Morocco"                 
[119] "Mozambique"               "Nauru"                   
[121] "Nepal"                    "Netherlands"             
[123] "Netherlands-Antilles"     "New-Zealand"             
[125] "Nicaragua"                "Niger"                   
[127] "Nigeria"                  "Niue"                    
[129] "North-Korea"              "North-Yemen"             
[131] "Norway"                   "Oman"                    
[133] "Pakistan"                 "Panama"                  
[135] "Papua-New-Guinea"         "Parguay"                 
[137] "Peru"                     "Philippines"             
[139] "Poland"                   "Portugal"                
[141] "Puerto-Rico"              "Qatar"                   
[143] "Romania"                  "Rwanda"                  
[145] "San-Marino"               "Sao-Tome"                
[147] "Saudi-Arabia"             "Senegal"                 
[149] "Seychelles"               "Sierra-Leone"            
[151] "Singapore"                "Soloman-Islands"         
[153] "Somalia"                  "South-Africa"            
[155] "South-Korea"              "South-Yemen"             
[157] "Spain"                    "Sri-Lanka"               
[159] "St-Helena"                "St-Kitts-Nevis"          
[161] "St-Lucia"                 "St-Vincent"              
[163] "Sudan"                    "Surinam"                 
[165] "Swaziland"                "Sweden"                  
[167] "Switzerland"              "Syria"                   
[169] "Taiwan"                   "Tanzania"                
[171] "Thailand"                 "Togo"                    
[173] "Tonga"                    "Trinidad-Tobago"         
[175] "Tunisia"                  "Turkey"                  
[177] "Turks-Cocos-Islands"      "Tuvalu"                  
[179] "UAE"                      "Uganda"                  
[181] "UK"                       "Uruguay"                 
[183] "US-Virgin-Isles"          "USA"                     
[185] "USSR"                     "Vanuatu"                 
[187] "Vatican-City"             "Venezuela"               
[189] "Vietnam"                  "Western-Samoa"           
[191] "Yugoslavia"               "Zaire"                   
[193] "Zambia"                   "Zimbabwe"                

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
[1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31
[13]    23   113    47  1099   600  8512     6   111   274   678    28   474
[25]  9976     4   623  1284   757  9561  1139     2   342    51   115     9
[37]   128    43    22    49   284  1001    21  1222    12    18   337   547
[49]    91   268    10   108   249   239   132  2176   109   246    36   215
[61]   112    93   103  3268  1904  1648   435    70   301   323    11   372
[73]    98   181   583   236    30  1760     3   587   118   333  1240  1031
[85]  1973  1566   447   783   140    41  1267   925   121   195   324   212
[97]   804    76   463   407  1285   300   313    92   237    26  2150   196
[109]    72   637  1221    99   288   505    66  2506    63    17   450   185
[121]   945   514    57     5   164   781   245   178  9363 22402    15   912
[133]   256   905   753   391

$population
[1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9
[15]   35    4   24    2   11 1008    5   47   31   54   17   61   14  684
[29]  157   39   57  118   13   77   12   56   18   84   48   36   22   29
[43]   38   49   45  231  274   60

$language
[1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
[1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] "green"  "red"    "blue"   "gold"   "white"  "orange" "black"  "brown" 

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
[1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] "black"  "red"    "green"  "blue"   "white"  "orange" "gold"  

$botright
[1] "green"  "red"    "white"  "black"  "blue"   "gold"   "orange" "brown" 


| Perseverance, that's the answer.

  |============================================================       |  90%
| Occasionally, you may need to apply a function that is not yet defined,
| thus requiring you to write your own. Writing functions in R is beyond the
| scope of this lesson, but let's look at a quick example of how you might
| do so in the context of loop functions.

...

|==============================================================     |  92%
| Pretend you are interested in only the second item from each element of
| the unique_vals list that you just created. Since each element of the
| unique_vals list is a vector and we're not aware of any built-in function
| in R that returns the second element of a vector, we will construct our
| own function.

...

  |===============================================================    |  94%
| lapply(unique_vals, function(elem) elem[2]) will return a list containing
| the second item from each element of the unique_vals list. Note that our
| function takes one argument, elem, which is just a 'dummy variable' that
| takes on the value of each element of unique_vals, in turn.

> lapply(unique_vals, function(elem) elem[2])
$name
[1] "Albania"

$landmass
[1] 3

$zone
[1] 3

$area
[1] 29

$population
[1] 3

$language
[1] 6

$religion
[1] 6

$bars
[1] 2

$stripes
[1] 0

$colours
[1] 3

$red
[1] 0

$green
[1] 0

$blue
[1] 1

$gold
[1] 0

$white
[1] 0

$black
[1] 0

$orange
[1] 1

$mainhue
[1] "red"

$circles
[1] 1

$crosses
[1] 1

$saltires
[1] 1

$quarters
[1] 1

$sunstars
[1] 0

$crescent
[1] 1

$triangle
[1] 1

$icon
[1] 0

$animate
[1] 1

$text
[1] 1

$topleft
[1] "red"

$botright
[1] "red"


| You got it!

  |================================================================   |  96%
| The only difference between previous examples and this one is that we are
| defining and using our own function right in the call to lapply(). Our
| function has no name and disappears as soon as lapply() is done using it.
| So-called 'anonymous functions' can be very useful when one of R's
| built-in functions isn't an option.

...

  |================================================================== |  98%
| In this lesson, you learned how to use the powerful lapply() and sapply()
| functions to apply an operation over the elements of a list. In the next
| lesson, we'll take a look at some close relatives of lapply() and
| sapply().

...

|===================================================================| 100%
| Would you like to receive credit for completing this course on
| Coursera.org?
    
    1: No
2: Yes

Selection: 2
What is your email address? hkuk97@gmail.com
What is your assignment token? vhZXScSiDeyRfHc7
Grade submission succeeded!
    
    | You are really on a roll!
    
    | You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 11

  |                                                                   |   0%

| In the last lesson, you learned about the two most fundamental members of
| R's *apply family of functions: lapply() and sapply(). Both take a list as
| input, apply a function to each element of the list, then combine and
| return the result. lapply() always returns a list, whereas sapply()
| attempts to simplify the result.

...

|===                                                                |   4%
| In this lesson, you'll learn how to use vapply() and tapply(), each of
| which serves a very specific purpose within the Split-Apply-Combine
| methodology. For consistency, we'll use the same dataset we used in the
| 'lapply and sapply' lesson.

...

|=====                                                              |   8%
| The Flags dataset from the UCI Machine Learning Repository contains
| details of various nations and their flags. More information may be found
| here: http://archive.ics.uci.edu/ml/datasets/Flags

...

|========                                                           |  12%
| I've stored the data in a variable called flags. If it's been a while
| since you completed the 'lapply and sapply' lesson, you may want to
| reacquaint yourself with the data by using functions like dim(), head(),
| str(), and summary() when you return to the prompt (>). You can also type
| viewinfo() at the prompt to bring up some documentation for the dataset.
| Let's get started!

...

  |===========                                                        |  16%
| As you saw in the last lesson, the unique() function returns a vector of
| the unique values contained in the object passed to it. Therefore,
| sapply(flags, unique) returns a list containing one vector of unique
| values for each column of the flags dataset. Try it again now.

> sapply(flags, unique)
$name
  [1] "Afghanistan"              "Albania"                 
  [3] "Algeria"                  "American-Samoa"          
  [5] "Andorra"                  "Angola"                  
  [7] "Anguilla"                 "Antigua-Barbuda"         
  [9] "Argentina"                "Argentine"               
 [11] "Australia"                "Austria"                 
 [13] "Bahamas"                  "Bahrain"                 
 [15] "Bangladesh"               "Barbados"                
 [17] "Belgium"                  "Belize"                  
 [19] "Benin"                    "Bermuda"                 
 [21] "Bhutan"                   "Bolivia"                 
 [23] "Botswana"                 "Brazil"                  
 [25] "British-Virgin-Isles"     "Brunei"                  
 [27] "Bulgaria"                 "Burkina"                 
 [29] "Burma"                    "Burundi"                 
 [31] "Cameroon"                 "Canada"                  
 [33] "Cape-Verde-Islands"       "Cayman-Islands"          
 [35] "Central-African-Republic" "Chad"                    
 [37] "Chile"                    "China"                   
 [39] "Colombia"                 "Comorro-Islands"         
 [41] "Congo"                    "Cook-Islands"            
 [43] "Costa-Rica"               "Cuba"                    
 [45] "Cyprus"                   "Czechoslovakia"          
 [47] "Denmark"                  "Djibouti"                
 [49] "Dominica"                 "Dominican-Republic"      
 [51] "Ecuador"                  "Egypt"                   
 [53] "El-Salvador"              "Equatorial-Guinea"       
 [55] "Ethiopia"                 "Faeroes"                 
 [57] "Falklands-Malvinas"       "Fiji"                    
 [59] "Finland"                  "France"                  
 [61] "French-Guiana"            "French-Polynesia"        
 [63] "Gabon"                    "Gambia"                  
 [65] "Germany-DDR"              "Germany-FRG"             
 [67] "Ghana"                    "Gibraltar"               
 [69] "Greece"                   "Greenland"               
 [71] "Grenada"                  "Guam"                    
 [73] "Guatemala"                "Guinea"                  
 [75] "Guinea-Bissau"            "Guyana"                  
 [77] "Haiti"                    "Honduras"                
 [79] "Hong-Kong"                "Hungary"                 
 [81] "Iceland"                  "India"                   
 [83] "Indonesia"                "Iran"                    
 [85] "Iraq"                     "Ireland"                 
 [87] "Israel"                   "Italy"                   
 [89] "Ivory-Coast"              "Jamaica"                 
 [91] "Japan"                    "Jordan"                  
 [93] "Kampuchea"                "Kenya"                   
 [95] "Kiribati"                 "Kuwait"                  
 [97] "Laos"                     "Lebanon"                 
 [99] "Lesotho"                  "Liberia"                 
[101] "Libya"                    "Liechtenstein"           
[103] "Luxembourg"               "Malagasy"                
[105] "Malawi"                   "Malaysia"                
[107] "Maldive-Islands"          "Mali"                    
[109] "Malta"                    "Marianas"                
[111] "Mauritania"               "Mauritius"               
[113] "Mexico"                   "Micronesia"              
[115] "Monaco"                   "Mongolia"                
[117] "Montserrat"               "Morocco"                 
[119] "Mozambique"               "Nauru"                   
[121] "Nepal"                    "Netherlands"             
[123] "Netherlands-Antilles"     "New-Zealand"             
[125] "Nicaragua"                "Niger"                   
[127] "Nigeria"                  "Niue"                    
[129] "North-Korea"              "North-Yemen"             
[131] "Norway"                   "Oman"                    
[133] "Pakistan"                 "Panama"                  
[135] "Papua-New-Guinea"         "Parguay"                 
[137] "Peru"                     "Philippines"             
[139] "Poland"                   "Portugal"                
[141] "Puerto-Rico"              "Qatar"                   
[143] "Romania"                  "Rwanda"                  
[145] "San-Marino"               "Sao-Tome"                
[147] "Saudi-Arabia"             "Senegal"                 
[149] "Seychelles"               "Sierra-Leone"            
[151] "Singapore"                "Soloman-Islands"         
[153] "Somalia"                  "South-Africa"            
[155] "South-Korea"              "South-Yemen"             
[157] "Spain"                    "Sri-Lanka"               
[159] "St-Helena"                "St-Kitts-Nevis"          
[161] "St-Lucia"                 "St-Vincent"              
[163] "Sudan"                    "Surinam"                 
[165] "Swaziland"                "Sweden"                  
[167] "Switzerland"              "Syria"                   
[169] "Taiwan"                   "Tanzania"                
[171] "Thailand"                 "Togo"                    
[173] "Tonga"                    "Trinidad-Tobago"         
[175] "Tunisia"                  "Turkey"                  
[177] "Turks-Cocos-Islands"      "Tuvalu"                  
[179] "UAE"                      "Uganda"                  
[181] "UK"                       "Uruguay"                 
[183] "US-Virgin-Isles"          "USA"                     
[185] "USSR"                     "Vanuatu"                 
[187] "Vatican-City"             "Venezuela"               
[189] "Vietnam"                  "Western-Samoa"           
[191] "Yugoslavia"               "Zaire"                   
[193] "Zambia"                   "Zimbabwe"                

$landmass
[1] 5 3 4 6 1 2

$zone
[1] 1 3 2 4

$area
  [1]   648    29  2388     0  1247  2777  7690    84    19     1   143    31
 [13]    23   113    47  1099   600  8512     6   111   274   678    28   474
 [25]  9976     4   623  1284   757  9561  1139     2   342    51   115     9
 [37]   128    43    22    49   284  1001    21  1222    12    18   337   547
 [49]    91   268    10   108   249   239   132  2176   109   246    36   215
 [61]   112    93   103  3268  1904  1648   435    70   301   323    11   372
 [73]    98   181   583   236    30  1760     3   587   118   333  1240  1031
 [85]  1973  1566   447   783   140    41  1267   925   121   195   324   212
 [97]   804    76   463   407  1285   300   313    92   237    26  2150   196
[109]    72   637  1221    99   288   505    66  2506    63    17   450   185
[121]   945   514    57     5   164   781   245   178  9363 22402    15   912
[133]   256   905   753   391

$population
 [1]   16    3   20    0    7   28   15    8   90   10    1    6  119    9
[15]   35    4   24    2   11 1008    5   47   31   54   17   61   14  684
[29]  157   39   57  118   13   77   12   56   18   84   48   36   22   29
[43]   38   49   45  231  274   60

$language
 [1] 10  6  8  1  2  4  3  5  7  9

$religion
[1] 2 6 1 0 5 3 4 7

$bars
[1] 0 2 3 1 5

$stripes
 [1]  3  0  2  1  5  9 11 14  4  6 13  7

$colours
[1] 5 3 2 8 6 4 7 1

$red
[1] 1 0

$green
[1] 1 0

$blue
[1] 0 1

$gold
[1] 1 0

$white
[1] 1 0

$black
[1] 1 0

$orange
[1] 0 1

$mainhue
[1] "green"  "red"    "blue"   "gold"   "white"  "orange" "black"  "brown" 

$circles
[1] 0 1 4 2

$crosses
[1] 0 1 2

$saltires
[1] 0 1

$quarters
[1] 0 1 4

$sunstars
 [1]  1  0  6 22 14  3  4  5 15 10  7  2  9 50

$crescent
[1] 0 1

$triangle
[1] 0 1

$icon
[1] 1 0

$animate
[1] 0 1

$text
[1] 0 1

$topleft
[1] "black"  "red"    "green"  "blue"   "white"  "orange" "gold"  

$botright
[1] "green"  "red"    "white"  "black"  "blue"   "gold"   "orange" "brown" 


| You nailed it! Good job!

  |=============                                                      |  20%
| What if you had forgotten how unique() works and mistakenly thought it
| returns the *number* of unique values contained in the object passed to
| it? Then you might have incorrectly expected sapply(flags, unique) to
| return a numeric vector, since each element of the list returned would
| contain a single number and sapply() could then simplify the result to a
| vector.

...

  |================                                                   |  24%
| When working interactively (at the prompt), this is not much of a problem,
| since you see the result immediately and will quickly recognize your
| mistake. However, when working non-interactively (e.g. writing your own
| functions), a misunderstanding may go undetected and cause incorrect
| results later on. Therefore, you may wish to be more careful and that's
| where vapply() is useful.

...

|===================                                                |  28%
| Whereas sapply() tries to 'guess' the correct format of the result,
| vapply() allows you to specify it explicitly. If the result doesn't match
| the format you specify, vapply() will throw an error, causing the
| operation to stop. This can prevent significant problems in your code that
| might be caused by getting unexpected return values from sapply().

...

  |=====================                                              |  32%
| Try vapply(flags, unique, numeric(1)), which says that you expect each
| element of the result to be a numeric vector of length 1. Since this is
| NOT actually the case, YOU WILL GET AN ERROR. Once you get the error, type
| ok() to continue to the next question.

> vapply(flags, unique, numeric(1))
Error in vapply(flags, unique, numeric(1)) : values must be length 1,
 but FUN(X[[1]]) result is length 194
> ok()

| Perseverance, that's the answer.

|========================                                           |  36%
| Recall from the previous lesson that sapply(flags, class) will return a
| character vector containing the class of each column in the dataset. Try
| that again now to see the result.

> sapply(flags, class)
name    landmass        zone        area  population    language 
"character"   "integer"   "integer"   "integer"   "integer"   "integer" 
religion        bars     stripes     colours         red       green 
"integer"   "integer"   "integer"   "integer"   "integer"   "integer" 
blue        gold       white       black      orange     mainhue 
"integer"   "integer"   "integer"   "integer"   "integer" "character" 
circles     crosses    saltires    quarters    sunstars    crescent 
"integer"   "integer"   "integer"   "integer"   "integer"   "integer" 
triangle        icon     animate        text     topleft    botright 
"integer"   "integer"   "integer"   "integer" "character" "character" 

| You got it right!
    
    |===========================                                        |  40%
| If we wish to be explicit about the format of the result we expect, we can
| use vapply(flags, class, character(1)). The 'character(1)' argument tells
| R that we expect the class function to return a character vector of length
| 1 when applied to EACH column of the flags dataset. Try it now.

> vapply(flags, class, character(1))
name    landmass        zone        area  population    language 
"character"   "integer"   "integer"   "integer"   "integer"   "integer" 
religion        bars     stripes     colours         red       green 
"integer"   "integer"   "integer"   "integer"   "integer"   "integer" 
blue        gold       white       black      orange     mainhue 
"integer"   "integer"   "integer"   "integer"   "integer" "character" 
circles     crosses    saltires    quarters    sunstars    crescent 
"integer"   "integer"   "integer"   "integer"   "integer"   "integer" 
triangle        icon     animate        text     topleft    botright 
"integer"   "integer"   "integer"   "integer" "character" "character" 

| You got it right!
    
    |=============================                                      |  44%
| Note that since our expectation was correct (i.e. character(1)), the
| vapply() result is identical to the sapply() result -- a character vector
| of column classes.

...

|================================                                   |  48%
| You might think of vapply() as being 'safer' than sapply(), since it
| requires you to specify the format of the output in advance, instead of
| just allowing R to 'guess' what you wanted. In addition, vapply() may
| perform faster than sapply() for large datasets. However, when doing data
| analysis interactively (at the prompt), sapply() saves you some typing and
| will often be good enough.

...

|===================================                                |  52%
| As a data analyst, you'll often wish to split your data up into groups
| based on the value of some variable, then apply a function to the members
| of each group. The next function we'll look at, tapply(), does exactly
| that.

...

|======================================                             |  56%
| Use ?tapply to pull up the documentation.

> ?tapply

| You are really on a roll!
    
    |========================================                           |  60%
| The 'landmass' variable in our dataset takes on integer values between 1
| and 6, each of which represents a different part of the world. Use
| table(flags$landmass) to see how many flags/countries fall into each
| group.

> table(flags$landmass)

1  2  3  4  5  6 
31 17 35 52 39 20 

| You are quite good my friend!
    
    |===========================================                        |  64%
| The 'animate' variable in our dataset takes the value 1 if a country's
| flag contains an animate image (e.g. an eagle, a tree, a human hand) and 0
| otherwise. Use table(flags$animate) to see how many flags contain an
| animate image.

> table(flags$animate)

  0   1 
155  39 

| This tells us that 39 flags contain an animate object (animate = 1) and
| 155 do not (animate = 0).


| If you take the arithmetic mean of a bunch of 0s and 1s, you get the
| proportion of 1s. Use tapply(flags$animate, flags$landmass, mean) to apply
| the mean function to the 'animate' variable separately for each of the six
| landmass groups, thus giving us the proportion of flags containing an
| animate image WITHIN each landmass group.

> tapply(flags$animate, flags$landmass, mean)
        1         2         3         4         5         6 
0.4193548 0.1764706 0.1142857 0.1346154 0.1538462 0.3000000 

| The first landmass group (landmass = 1) corresponds to North America and
| contains the highest proportion of flags with an animate image (0.4194).


 Similarly, we can look at a summary of population values (in round
| millions) for countries with and without the color red on their flag with
| tapply(flags$population, flags$red, summary).

> tapply(flags$population, flags$red, summary)
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    3.00   27.63    9.00  684.00 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0     0.0     4.0    22.1    15.0  1008.0 
    

| What is the median population (in millions) for countries *without* the
| color red on their flag?

1: 27.6
2: 22.1
3: 9.0
4: 3.0
5: 4.0
6: 0.0

Selection: 2


| Lastly, use the same approach to look at a summary of population values
| for each of the six landmasses.

> tapply(flags$population, flags$landmass, summary)
$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   12.29    4.50  231.00 

$`2`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    1.00    6.00   15.71   15.00  119.00 

$`3`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    8.00   13.86   16.00   61.00 

$`4`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.000   5.000   8.788   9.750  56.000 

$`5`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    2.00   10.00   69.18   39.00 1008.00 

$`6`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00    0.00    0.00   11.30    1.25  157.00 
   
 
| What is the maximum population (in millions) for the fourth landmass group
| (Africa)?

1: 5.00
2: 119.0
3: 157.00
4: 56.00
5: 1010.0

Selection: 4



library(datasets)
data(iris)


Q


